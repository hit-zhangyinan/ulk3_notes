# 第 2 章 内存寻址

## 内存地址

线性地址也称为虚拟地址

MMU 完成从虚拟地址 VA 到物理地址 PA 的转换

## 硬件中的分段

从 80286 开始，intel 处理器以两种方式执行地址转换：实模式和保护模式

逻辑地址由两部分组成：段标识符 + 指定段内相对地址的偏移量

更具体一点是：16 位段选择符 + 32 位偏移量

CPU 的当前特权级 (current privilege level, CPL)，0 代表最高优先级，3 是最低

Linux 只用 0 和 3，分别是内核态和用户态

全局描述符表 (global descriptor table, GDT)

局部描述符表 (local descriptor table, LDT)

在 Linux 下逻辑地址与线性地址 (虚拟地址) 是一致的

## 硬件中的分页

虚拟地址被分成以固定长度为单位的组，称为页 (page)

页内部连续的虚拟地址被映射到连续的物理地址中

分页单元把所有的 RAM 分成固定长度的页框 (page frame) (物理页)

每一个 page frame 包含一个 page，也就是 page frame 的长度和 page 的长度一样

把虚拟地址映射到物理地址的数据结构是页表 (page table)

页表放在主存 (RAM) 中，在启用分页单元之前必须对页表进行初始化

从 80386 开始，所有的 x86 处理器都支持分页，分页单元处理 4KB 的页

32 位的虚拟地址被划分为 3 部分：

10 bit 的目录 + 10 bit 的表 + 12 bit 的偏移量

使用二级模式的目的在于减少进程页表所需 RAM 的数量

### 扩展分页

从 Pentium 开始，x86 引入了扩展分页，允许页框大小为 4MB

扩展分页用于把大段连续的虚拟地址转换成相应的物理地址

当启用扩展分页功能时，32 位的虚拟地址被分成两部分：

10 bit 的目录 + 22 bit 的偏移量

### 常规分页举例

缺页异常 (Page Fault exception)

### 物理地址扩展分页机制

物理地址扩展 (Physical Address Extension, PAE) 并没有扩大进程的线性地址空间，因为它只处理物理地址

### 64 位系统中的分页

|  平台名称  |  页大小  | 寻址使用的位数 | 分页级别数 |     线性地址分级    |
| --------- | -------- | :-----------: |  :-----:  |  ----------------  |
|   x86_64  |   4KB    |       48      |     4     | 9 + 9 + 9 + 9 + 12 |

### 硬件高速缓存 (Hardware Cache)

在通写 (write-through) 中，总是既写 RAM 也写高速缓存行

在回写 (write-back) 中，只更新高速缓存行，不改变 RAM 的内容

当 FLUSH 硬件信号产生时 (通常在高速缓存不命中之后)，把高速缓存行写回到 RAM 中

Linux 对于所有的页框都启用高速缓存，对于写操作总是采用回写策略

## Linux 中的分页

从 Linux 2.6.11 版本开始，采用四级分页模型

线性地址被分成五个部分

### 物理内存布局

在初始化阶段，内核必须指定哪些物理地址范围对内核可用而哪些不可用

内核将一部分页框标记为保留，这些页框中的页不能被动态分配或交换到磁盘上

Linux 用未保留的页框来动态存放所分配的页

### 进程页表

1GB = 0x 4000 0000

3GB = 0x c000 0000

4GB = 0x 1 0000 0000

进程的线性地址空间分成两部分：

* 从 0x 0000 0000 到 0x bfff ffff 的线性地址，用户态和内核态都可以寻址

* 从 0x c000 0000 到 0x ffff ffff 的线性地址，只有内核态才能寻址

### 处理 TLB

处理器不能自动同步它们自己的 TLB

决定线性地址和物理地址之间映射何时不再有效的是内核，而不是硬件

Linux 提供了几种在合适时机应当使用的 TLB 刷新方法
